<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>适配方案三</title>
	<style>
		body {
			padding: 0;
			margin: 0;
			background-color: #F7F7F7;
		}

		/*公司开发，按着UI稿件进行网页布局*/

		/* 640 和 750 并存状态 */

		/*公式*/

		/*1、将UI图（假设640px）分成若干份（如20份）*/
		/*2、UI图宽度（640px） / 若干份（20份）= 基数（32）*/

		/* 每份 32px */
		/* 问16像素占多份？16 / 32 = 0.5份 */

		/*3、结合媒体查询，检测屏幕宽度（layout viewport）*/
		/*4、layout viewport 宽度 / 若干份（20份）= font-size*/

		/* 每份 font-size */
		/* 0.5份 * font-size = 在不同设备下的实际大小 */

		/*常见屏幕尺寸 320、360、375、400、414*/
		
		/*分成20份*/


		/*
			移动端知识点，用rem实现屏幕比例适配

			说这么复杂，核心一样
			就是iOS中的：
				HEIGHT()    WEIGHT()
				实际长度 =  标注长度 * 标注图的宽度/ 设备宽度
￼
			不过前端是通过一个rem的单位来实现的

				实际长度  =  标注长度 * 标注的单位rem(比率与后面这个一致) / 上面声明写的各种设备宽度对应的rem(一般是屏幕宽度/20)


		一方面rem做了屏幕适配，另一方面，这个单位也可以用来规定字体
		我感觉前端这样，是因为css里没有宏定义这个做法，然后因为ios那样写，数字太大，所以找了个公因数，除了一下

		 */



		@media only screen and (width: 320px) {
			html {
				font-size: 16px;
			}
		}

		@media only screen and (width: 360px) {
			html {
				font-size: 18px;
			}
		}

		@media only screen and (width: 375px) {
			html {
				font-size: 18.75px;
			}
		}

		@media only screen and (width: 400px) {
			html {
				font-size: 20px;
			}
		}

		@media only screen and (width: 412px) {
			html {
				font-size: 20.6px;
			}
		}

		@media only screen and (width: 414px) {
			html {
				font-size: 20.7px;
			}
		}

		.box {
			width: 5rem;
			height: 5rem;
			background-color: pink;
		}
		
	</style>
</head>
<body>
	<div class="box">
	</div>


	<script>
		
	 	var viewport = document.documentElement;

	 	var width = viewport.clientWidth;

	 	var fontSize = width / 20;

	 	viewport.style.fontSize = fontSize;

	</script>
</body>
</html>